# Java-Design-model
for exercise 

spring 中存在的比较常见的几种设计模式

1. 代理模式
        现实场景：中介，黄牛，媒婆，经纪人 
        什么时候使用：
        1）执行者，被代理人
        2）对于被代理人来说，这件事情必须去做但是因为种种原因无法去做（缺少手头资源，行情不熟悉）
        3）需要获得被代理人的资料
        其他分支：
        jdk实现的动态代理，cglib实现的动态代理
        其他：字节码的重组
2. 工厂模式
        现实场景：车厂
        什么时候使用：不关心生产过程，我只关心成品，所以工厂模式是注重结果的
        对于客户而言无感知。
        其他分支：简单工厂（功能太过强大，现实中不符合逻辑），工厂方法（让客户直接去面对了工厂，不符合逻辑）
        抽象工厂（存在defaultFactory存在，可以让工厂默认去制造一些什么，客户只需要传入名字就可以生产，封装了复制的逻辑）
        其他：抽象工厂在工厂这层进行了抽象，并只初始化默认的工厂，原有工厂逻辑不会受到影响，spring中的beanFactory常用
3. 单例模式
        现实场景：配置文件，直接上级
        什么时候使用：
        1）一个系统开启到结束只允许一个实例存在
        2）当我们在应用中遇到功能性上的冲突时，使用单例
        其他分支：单例模式的其他类别有七种，这里只是列举了比较经典的一种，大部分单例考虑了使用上的单例
        而没有考虑线程安全
        其他：暂无
4. 委托模式
        现实场景：项目经理和你
        什么时候使用：
        1）类似中介的功能
        2）持有被委托人的引用（接口或者抽象类）
        3）不关心过程，只关心结果
        其他分支：主要是为了隐藏具体干活细节
        其他：干活是我的，功劳是你的
5. 策略模式
        现实场景：去某一个地方
        什么时候使用：java中的比较器是一个明显的策略模式
        其他分支：暂无
        其他：暂无
6. 原型模式
        现实场景：美猴王
        什么时候使用：某个实例属性过多，重新赋值过于麻烦
        其他分支：java中常用的原型模式就是使用克隆，克隆分为浅克隆和深克隆
        浅克隆在于可能复制对象中的八大基本类型+String，如果使用其他的会于原型共享同一地址
        如果需要实现深度克隆必须自己重新书写克隆方法
        其他：orm常用
7. 模板模式
        现实场景：烧水壶
        什么时候使用：有固定的流程，所以模板模式关心的是流程
        其他分支：接口或者抽象方法将固定的方法实现好，对于未知的方法让其他人实现
        orm框架中，数据库的语法各有不同，所有由不同厂商去各自开发
        其他：orm常用
